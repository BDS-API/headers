#pragma once

class CommandRegistry {

public:
    static long CommandRegistry::TAG_VALUES_SOFTENUM_NAME;
    static long CommandRegistry::FUNCTION_NAME_SOFTENUM_NAME;
    static long CommandRegistry::COMMAND_NAME_ENUM_NAME;


    void collapse(CommandRegistry::ParseToken &, CommandRegistry::Symbol);
    void collapseOn(CommandRegistry::ParseToken &, CommandRegistry::Symbol, CommandRegistry::Symbol);
    void expand(CommandRegistry::ParseToken &, CommandRegistry::Symbol);
    void expandExcept(CommandRegistry::ParseToken &, CommandRegistry::Symbol, CommandRegistry::Symbol);
    void expandOn(CommandRegistry::ParseToken &, CommandRegistry::Symbol, CommandRegistry::Symbol);
    void fold(CommandRegistry::ParseToken &, CommandRegistry::Symbol, CommandRegistry::Symbol);
    void kill(CommandRegistry::ParseToken &, CommandRegistry::Symbol);
    void readFloat(float &, CommandRegistry::ParseToken const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &);
    void readInt(int &, CommandRegistry::ParseToken const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &);
    void readRelativeCoordinate(bool &, float &, CommandRegistry::ParseToken const&, bool, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &);
    void parseOperator(CommandOperator *, CommandRegistry::ParseToken const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &)const;
    void getEnumData(CommandRegistry::ParseToken const&)const;
    void parseSelector(CommandSelectorBase *, CommandRegistry::ParseToken const&, CommandOrigin const&, int, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &, bool)const;
    void _removeStringQuotes(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&);
    void createCommand(CommandRegistry::ParseToken const&, CommandOrigin const&, int, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &)const;
    void getParseSymbol(CommandParameterData const&);
    bool isParseMatch(CommandParameterData const&, CommandRegistry::Symbol);
    void getFieldSet(Command *, CommandParameterData const&);
    void getVersionField(Command *, CommandRegistry::Overload const&);
    void parseParameter(Command *, CommandParameterData const&, CommandRegistry::ParseToken const&, CommandOrigin const&, int, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> &, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> &)const;
    void findCommand(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void CommandRegistry(void);
    void addSoftTerminal(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&);
    void addEnumValues(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> const&);
    void addSoftEnum(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>>);
    void addRule(CommandRegistry::Symbol, std::vector<CommandRegistry::Symbol, std::allocator<CommandRegistry::Symbol>> &&, std::function<CommandRegistry::ParseToken * ()(std::function&, CommandRegistry::Symbol)>, CommandVersion);
    void findEnumValue(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void _addFunctionSoftEnum(void);
    void addSemanticConstraint(SemanticConstraint);
    void registerCommand(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, char const*, CommandPermissionLevel, CommandFlag, CommandFlag);
    void addEnumValuesInternal(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::pair<unsigned long, unsigned long>, std::allocator<std::pair<unsigned long, unsigned long>>> const&, typeid_t<CommandRegistry>, bool (CommandRegistry::*)(void *, CommandRegistry::ParseToken const&, CommandOrigin const&, int, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>&, std::vector&<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>>)const);
    void addEnumValueConstraints(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>> const&, SemanticConstraint);
    void registerAlias(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>);
    void setCommandRegistrationOverride(std::function<void ()(CommandFlag &, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)>);
    void getCommandName(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    bool isValidCommand(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void getCommandStatus(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    bool isCommandOfType(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, CommandTypeFlag)const;
    void requiresCheatsEnabled(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void getCommandsPermissionLevel(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void buildRules(CommandRegistry::Signature &, std::vector<CommandRegistry::Overload *, std::allocator<CommandRegistry::Overload *>> const&, unsigned long);
    void buildOptionalRuleChain(CommandRegistry::Signature const&, std::vector<CommandParameterData, std::allocator<CommandParameterData>> const&, CommandParameterData const*, unsigned long);
    void registerOverloadInternal(CommandRegistry::Signature &, CommandRegistry::Overload &);
    void addPostfix(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&);
    void setupOverloadRules(CommandRegistry::Signature &, CommandRegistry::Overload &);
    void findCommand(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&);
    void findEnum(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void findSoftEnum(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void findPostfix(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void findIdentifierInfo(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void buildOverload(CommandRegistry::Overload &);
    bool isValid(CommandRegistry::Symbol)const;
    bool isOptionalChainMatch(CommandRegistry::Symbol const*, CommandRegistry::OptionalParameterChain const*)const;
    void buildOptionalRuleChain(CommandRegistry::Signature const&, std::vector<CommandParameterData, std::allocator<CommandParameterData>> const&, std::vector const&<CommandRegistry::Symbol, std::allocator<std::vector const>>);
    void addSymbols(std::vector<CommandRegistry::Symbol, std::allocator<CommandRegistry::Symbol>> &, std::vector<CommandRegistry::Symbol, std::allocator<CommandRegistry::Symbol>> const&, bool);
    void buildFirstSet(CommandRegistry::ParseTable &, CommandRegistry::Symbol, unsigned int)const;
    void buildFollowSet(CommandRegistry::ParseTable &, CommandRegistry::Symbol, unsigned int, std::set<CommandRegistry::Symbol, std::less<CommandRegistry::Symbol>, std::allocator<CommandRegistry::Symbol>> &)const;
    void first(CommandRegistry::ParseTable &, std::vector<CommandRegistry::Symbol, std::allocator<CommandRegistry::Symbol>> const&)const;
    void forEachTerminal(std::function<void ()(CommandRegistry::Symbol)>)const;
    void forEachNonTerminal(std::function<void ()(CommandRegistry::Symbol)>)const;
    void buildParseTable(unsigned int)const;
    void addEnumValuesInternal(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, unsigned long>, std::allocator<std::pair<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, unsigned long>>> const&, typeid_t<CommandRegistry>, bool (CommandRegistry::*)(void *, CommandRegistry::ParseToken const&, CommandOrigin const&, int, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>&, std::vector&<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>>)const);
    void addEnumValuesToExisting(unsigned int, std::vector<std::pair<unsigned long, unsigned long>, std::allocator<std::pair<unsigned long, unsigned long>>> const&);
    void _addEnumValueConstraintsInternal(std::vector<std::pair<unsigned long, unsigned int>, std::allocator<std::pair<unsigned long, unsigned int>>> const&, SemanticConstraint);
    void _addEnumValueConstraintsToExisting(unsigned int, SemanticConstraint);
    void addSoftEnumValues(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>>);
    void setSoftEnumValues(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>>);
    void _broadcast(Packet const&)const;
    void removeSoftEnumValues(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, std::vector<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, std::allocator<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>>);
    void originCanRun(CommandOrigin const&, CommandRegistry::Signature const&)const;
    void autoCompleteCommand(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, CommandOrigin const&, AutoCompleteInformation &)const;
    void autoComplete(CommandRegistry::Symbol, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, bool, CommandOrigin const&, AutoCompleteInformation &, CommandRegistry::SemanticInfo &)const;
    void _matchesEnumConstraints(CommandRegistry::Symbol const&, CommandOrigin const&, CommandRegistry::Symbol const&)const;
    void parsePartialCommand(CommandRegistry::Parser &, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>, unsigned int, bool)const;
    void getAutoCompleteOptions(CommandOrigin const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, unsigned int)const;
    void _reconstructParseStack(std::vector<CommandParameterData, std::allocator<CommandParameterData>> const&, unsigned int, CommandRegistry::ParseToken const*, CommandRegistry::SemanticInfo &)const;
    void _reconstructParseStack(CommandRegistry::ParseToken const*, CommandRegistry::SemanticInfo &)const;
    void describe(CommandRegistry::Signature const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, CommandRegistry::Overload const&, unsigned int, unsigned int *, unsigned int *)const;
    void getCommandOverloadSyntaxInformation(CommandOrigin const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    void originCanRun(CommandOrigin const&, CommandRegistry::Overload const&)const;
    void getAliases(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&)const;
    bool canCommandBeUsed(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, CommandPermissionLevel const&, bool)const;
    void checkOriginCommandFlags(CommandOrigin const&, CommandFlag, CommandPermissionLevel)const;
    void _matchesEnumConstraintsExcept(CommandRegistry::Symbol const&, CommandOrigin const&, CommandRegistry::Symbol const&, SemanticConstraint)const;
    void originCanRunOverloadWithParam(CommandOrigin const&, CommandParameterData const&)const;
    void _getConstrainedParamEnumSymbol(CommandParameterData const&)const;
    void _getConstrainedParamEnumSymbol(CommandRegistry::Symbol)const;
    void _isParamFullyParsed(CommandRegistry::ParseToken const*)const;
    void _findValueConstraints(CommandRegistry::Symbol const&, CommandRegistry::Symbol const&)const;
    void _matchesEnumConstraints(CommandParameterData const&, CommandOrigin const&, CommandRegistry::ParseToken const&)const;
    void _matchesEnumConstraintsSet(CommandRegistry::Symbol const&, CommandOrigin const&, CommandRegistry::Symbol const&, SemanticConstraint)const;
    void getOverloadSyntaxInformation(CommandOrigin const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, unsigned int)const;
    bool hasCommands(void)const;
    bool hasState(void);
    void pushState(void);
    void popState(void);
    void serializeAvailableCommands(void)const;
    void loadRemoteCommands(AvailableCommandsPacket const&);
    void setNetworkUpdateCallback(std::function<void ()(Packet const&)>);
    void setScoreCallback(std::function<int ()(bool &, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> const&, Actor const&)>);
};
